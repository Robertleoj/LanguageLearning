{"message":"failed to resolve: use of undeclared type `IpAddrKind`","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared crate or module `ferris_wheel`\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":76,"byte_end":86,"line_start":8,"line_end":8,"column_start":16,"column_end":26,"is_primary":true,"text":[{"text":"    let four = IpAddrKind::V4;","highlight_start":16,"highlight_end":26}],"label":"use of undeclared type `IpAddrKind`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0433]\u001b[0m\u001b[0m\u001b[1m: failed to resolve: use of undeclared type `IpAddrKind`\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/main.rs:8:16\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m8\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    let four = IpAddrKind::V4;\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m               \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9muse of undeclared type `IpAddrKind`\u001b[0m\n\n"}
{"message":"failed to resolve: use of undeclared type `IpAddrKind`","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared crate or module `ferris_wheel`\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":106,"byte_end":116,"line_start":9,"line_end":9,"column_start":15,"column_end":25,"is_primary":true,"text":[{"text":"    let six = IpAddrKind::V6;","highlight_start":15,"highlight_end":25}],"label":"use of undeclared type `IpAddrKind`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0433]\u001b[0m\u001b[0m\u001b[1m: failed to resolve: use of undeclared type `IpAddrKind`\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/main.rs:9:15\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m9\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    let six = IpAddrKind::V6;\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m              \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9muse of undeclared type `IpAddrKind`\u001b[0m\n\n"}
{"message":"recursive type `Node` has infinite size","code":{"code":"E0072","explanation":"A recursive type has infinite size because it doesn't have an indirection.\n\nErroneous code example:\n\n```compile_fail,E0072\nstruct ListNode {\n    head: u8,\n    tail: Option<ListNode>, // error: no indirection here so impossible to\n                            //        compute the type's size\n}\n```\n\nWhen defining a recursive struct or enum, any use of the type being defined\nfrom inside the definition must occur behind a pointer (like `Box`, `&` or\n`Rc`). This is because structs and enums must have a well-defined size, and\nwithout the pointer, the size of the type would need to be unbounded.\n\nIn the example, the type cannot have a well-defined size, because it needs to be\narbitrarily large (since we would be able to nest `ListNode`s to any depth).\nSpecifically,\n\n```plain\nsize of `ListNode` = 1 byte for `head`\n                   + 1 byte for the discriminant of the `Option`\n                   + size of `ListNode`\n```\n\nOne way to fix this is by wrapping `ListNode` in a `Box`, like so:\n\n```\nstruct ListNode {\n    head: u8,\n    tail: Option<Box<ListNode>>,\n}\n```\n\nThis works because `Box` is a pointer, so its size is well-known.\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":1,"byte_end":10,"line_start":2,"line_end":2,"column_start":1,"column_end":10,"is_primary":true,"text":[{"text":"enum Node {","highlight_start":1,"highlight_end":10}],"label":"recursive type has infinite size","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":24,"byte_end":28,"line_start":3,"line_end":3,"column_start":12,"column_end":16,"is_primary":false,"text":[{"text":"    Branch(Node, Node),","highlight_start":12,"highlight_end":16}],"label":"recursive without indirection","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":30,"byte_end":34,"line_start":3,"line_end":3,"column_start":18,"column_end":22,"is_primary":false,"text":[{"text":"    Branch(Node, Node),","highlight_start":18,"highlight_end":22}],"label":"recursive without indirection","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"insert some indirection (e.g., a `Box`, `Rc`, or `&`) to make `Node` representable","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":24,"byte_end":24,"line_start":3,"line_end":3,"column_start":12,"column_end":12,"is_primary":true,"text":[{"text":"    Branch(Node, Node),","highlight_start":12,"highlight_end":12}],"label":null,"suggested_replacement":"Box<","suggestion_applicability":"HasPlaceholders","expansion":null},{"file_name":"src/main.rs","byte_start":28,"byte_end":28,"line_start":3,"line_end":3,"column_start":16,"column_end":16,"is_primary":true,"text":[{"text":"    Branch(Node, Node),","highlight_start":16,"highlight_end":16}],"label":null,"suggested_replacement":">","suggestion_applicability":"HasPlaceholders","expansion":null},{"file_name":"src/main.rs","byte_start":30,"byte_end":30,"line_start":3,"line_end":3,"column_start":18,"column_end":18,"is_primary":true,"text":[{"text":"    Branch(Node, Node),","highlight_start":18,"highlight_end":18}],"label":null,"suggested_replacement":"Box<","suggestion_applicability":"HasPlaceholders","expansion":null},{"file_name":"src/main.rs","byte_start":34,"byte_end":34,"line_start":3,"line_end":3,"column_start":22,"column_end":22,"is_primary":true,"text":[{"text":"    Branch(Node, Node),","highlight_start":22,"highlight_end":22}],"label":null,"suggested_replacement":">","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0072]\u001b[0m\u001b[0m\u001b[1m: recursive type `Node` has infinite size\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/main.rs:2:1\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m2\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0menum Node {\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mrecursive type has infinite size\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m3\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    Branch(Node, Node),\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m----\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m----\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mrecursive without indirection\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mrecursive without indirection\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to make `Node` representable\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m3\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    Branch(\u001b[0m\u001b[0m\u001b[38;5;10mBox<\u001b[0m\u001b[0mNode\u001b[0m\u001b[0m\u001b[38;5;10m>\u001b[0m\u001b[0m, \u001b[0m\u001b[0m\u001b[38;5;10mBox<\u001b[0m\u001b[0mNode\u001b[0m\u001b[0m\u001b[38;5;10m>\u001b[0m\u001b[0m),\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m           \u001b[0m\u001b[0m\u001b[38;5;10m++++\u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[38;5;10m+\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[38;5;10m++++\u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[38;5;10m+\u001b[0m\n\n"}
{"message":"aborting due to 3 previous errors","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: aborting due to 3 previous errors\u001b[0m\n\n"}
{"message":"Some errors have detailed explanations: E0072, E0433.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1mSome errors have detailed explanations: E0072, E0433.\u001b[0m\n"}
{"message":"For more information about an error, try `rustc --explain E0072`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1mFor more information about an error, try `rustc --explain E0072`.\u001b[0m\n"}
